local target = ...
local methodlist = require('<< mlmodule >>')<< mlsubmodule >>
local host = require('host')
local iterator = {}
local ffi = require('ffi')
local utility = require('base.utility')

iterator.instmeta = {
	__index = iterator}

function iterator:create()
	return self.metatype()
end

function iterator:inc()
	if not methodlist.<< mlprefix >>_iterator_inc(self) then
		host.checkerror()
	end
end

function iterator.instmeta.__eq(a, b)
	local cr = methodlist.<< mlprefix >>_iterator_eq(a, b)
	if cr == 0 then
		host.checkerror()
	else
		return cr == 1
	end
end

function iterator.instmeta:__call()
	return self:deref()
end

function iterator.instmeta:__gc()
	methodlist.<< mlprefix >>_iterator_close(self)
end

iterator.metatype = ffi.metatype('<< ffitype >>', iterator.instmeta)

if not target then
	return iterator
end

target.iterator = iterator

function target:_begin()
	local it = self.iterator:create()
	if not methodlist.<< mlprefix >>_begin(self.ptr, it) then
		host.checkerror()
		return nil
	end
	return it
end

function target:_end()
	local it = self.iterator:create()
	if not methodlist.<< mlprefix >>_end(self.ptr, it) then
		host.checkerror()
		return nil
	end
	return it
end

function target.<< targetmethod >>_iter(state)
	if state.inext == state.iend then
		return
	end
	local ret = utility.pack(state.inext())
	state.inext:inc()
	return ret()
end

function target:<< targetmethod >>()
	local state = {
		target = self,
		inext = self:_begin(),
		iend = self:_end()}
	return self.<< targetmethod >>_iter, state
end

return iterator
