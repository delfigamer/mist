cc.anychar := $any;
cc.letter := [A-Za-z_];
cc.decdigit := [0-9];
cc.hexdigit := [0-9A-Fa-f];
cc.letterordigit := [0-9A-Za-z_];
cc.whitespace := [\00-\20];
cc.whitespace_line := [\00-\09\0b\0c\0e-\20];
cc.newline := [\0a\0d];

blank := ~[] > *cc.whitespace;
identifier := ~keyword < $concat cc.letter : *cc.letterordigit;
swizzle := $concat identifier : '.' : (
	[xyzw] : ?[xyzw] : ?[xyzw] : ?[xyzw] /
	[rgba] : ?[rgba] : ?[rgba] : ?[rgba] /
	$error 'invalid swizzle' );
swizzle_unique := $concat identifier : '.' : (
	'xyzw' / 'xywz' / 'xzyw' / 'xzwy' / 'xwyz' / 'xwzy' /
	'yxzw' / 'yxwz' / 'yzxw' / 'yzwx' / 'ywxz' / 'ywzx' /
	'zxyw' / 'xzwy' / 'zyxw' / 'zywx' / 'zwxy' / 'zwyx' /
	'wxyz' / 'wxzy' / 'wyxz' / 'wyzx' / 'wzxy' / 'wzyx' /
	'xy':[zw] / 'xz':[yw] / 'xw':[yz] /
	'yx':[zw] / 'yz':[xw] / 'yw':[xz] /
	'zx':[yw] / 'zy':[xw] / 'zw':[xy] /
	'wx':[yz] / 'wy':[xz] / 'wz':[xy] /
	'x':[yzw] / 'y':[xzw] / 'z':[xyw] / 'w':[xyz] /
	[xyzw] /

	'rgba' / 'rgab' / 'rbga' / 'rbag' / 'ragb' / 'rabg' /
	'grba' / 'grab' / 'gbra' / 'gbar' / 'garb' / 'gabr' /
	'brga' / 'rbag' / 'bgra' / 'bgar' / 'barg' / 'bagr' /
	'argb' / 'arbg' / 'agrb' / 'agbr' / 'abrg' / 'abgr' /
	'rg':[ba] / 'rb':[ga] / 'ra':[gb] /
	'gr':[ba] / 'gb':[ra] / 'ga':[rb] /
	'br':[ga] / 'bg':[ra] / 'ba':[rg] /
	'ar':[gb] / 'ag':[rb] / 'ab':[rg] /
	'r':[gba] / 'g':[rba] / 'b':[rga] / 'a':[rgb] /
	[rgba] /
	$error 'invalid swizzle' );

$pr keyword;

$function kw;
	rule := $arg 1 > ~cc.letterordigit;
	keyword <= rule;
	$return rule;
$end;

kw.attribute := $call kw { 'attribute' };
kw.const := $call kw { 'const' };
kw.float := $call kw { 'float' };
kw.float2 := $call kw { 'float2' };
kw.float3 := $call kw { 'float3' };
kw.float4 := $call kw { 'float4' };
kw.float4x4 := $call kw { 'float4x4' };
kw.fragment := $call kw { 'fragment' };
kw.return := $call kw { 'return' };
kw.texture := $call kw { 'texture' };
kw.varying := $call kw { 'varying' };
kw.vertex := $call kw { 'vertex' };
kw.uniform := $call kw { 'uniform' };

$pr expression;
$pr expr.simple;
expr.identref {
	target = swizzle / identifier,
};
expr.simple <= expr.identref;
expr.simple <= expr.number {
	value = $concat (
		?'-' : ('0x' / '0X') : %cc.hexdigit /
		?'-' : %cc.decdigit : '.' : *cc.decdigit : [eE] : ?[+-] : %cc.decdigit /
		?'-' : *cc.decdigit : '.' : %cc.decdigit : [eE] : ?[+-] : %cc.decdigit /
		?'-' : %cc.decdigit : '.' : *cc.decdigit /
		?'-' : *cc.decdigit : '.' : %cc.decdigit /
		?'-' : %cc.decdigit),
};
expr.simple < -10 = expr.funccall {
	func = identifier / typename,
	blank '(' blank,
	args = ?(expression : *( blank ',' blank < $assert expression )),
	blank $assert ')',
};
/*expr.simple <= expr.negate {
	'-' blank,
	value = expr.simple,
};*/
expr.simple <= '(' blank < expression > blank ')';
$binary expr.mul_or_div {
	expr.simple,
	blank < ('*' / '/') > blank,
	expr.simple,
};
$binary expr.add_or_sub {
	expr.mul_or_div,
	blank < ('+' / '-') > blank,
	expr.mul_or_div,
};
expression <= expr.add_or_sub;

$pr typename;
typename <= kw.float;
typename <= kw.float2;
typename <= kw.float3;
typename <= kw.float4;
typename <= kw.float4x4;

type {
	name = typename,
};

$pr modifier;
modifier.attribute.source :=
	'position' / 'texcoord1' / 'texcoord2' / 'color';
modifier <= modifier.attribute{
	kw.attribute blank,
	source = modifier.attribute.source,
};
modifier <= modifier.const{
	kw.const,
};
modifier <= modifier.varying{
	kw.varying,
};
modifier <= modifier.uniform{
	kw.uniform,
};

statement_error := $error 'statement expected';

ssep := blank ?(';' blank);

$pr statement;
stat.var := stat.var {
	modifier = ?(modifier > blank),
	type = type,
	blank,
	name = $assert identifier,
	blank '=' blank,
	value = $assert expression,
} / stat.var {
	modifier = ?(modifier > blank),
	type = type,
	blank,
	name = $assert identifier,
	value = $dummy,
};
statement <= stat.var;
texture_index := [0-7];
statement <= stat.texture {
	kw.texture blank,
	index = $assert texture_index,
	blank,
	name = $assert identifier,
};
statement <= stat.assignment {
	target = swizzle_unique / identifier,
	blank '=' blank,
	source = $assert expression,
};
stat.return {
	kw.return blank,
	value = $assert expression,
};

body {
	common = *(stat.var > ssep),
	$assert kw.vertex blank,
	vertex = *(statement > ssep),
	vertexreturn = $assert stat.return > ssep,
	$assert kw.fragment blank,
	fragment = *(statement > ssep),
	fragmentreturn = $assert stat.return > ssep
};

$return blank < body > blank &$assert $eof;
