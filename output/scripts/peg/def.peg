anychar := $any;
letter := [0-9A-Za-z\_\.];
digit := [0-9];
hexdigit := [0-9A-Za-z];
whitespace := [\00-\20];
comment_line := '//' *[~\0a];
comment_ml := '/*' *(comment_ml / ~'*/' < anychar) $assert '*/';
blank := *(whitespace / comment_line / comment_ml);
number := $concat ?'-' : %digit;
identifier_argref {
	'$narg' blank,
	index = $assert number};
identifier :=
	$concat %letter /
	identifier_argref;
str_char := [~'];
str_chunk := $concat *str_char;
str_content := str_chunk : *('''''' < str_chunk);
str_literal {
	'''',
	content = str_content,
	$assert ''''};
str := str_literal;
charclasshexchar {
	'\',
	hi = hexdigit,
	lo = hexdigit};
charclassescapechar {
	'\',
	char = anychar};
charclassplainchar_b := [~\]];
charclassplainchar {
	char = charclassplainchar_b};
charclasschar :=
	charclasshexchar /
	charclassescapechar /
	charclassplainchar;
charclasscharelement {
	char = charclasschar};
charclassrangeelement {
	first = charclasschar,
	'-',
	last = charclasschar};
charclasscontentelement :=
	charclassrangeelement /
	charclasscharelement;
charclasscontent :=
	*charclasscontentelement;
charclass {
	'[',
	invert = ?'~',
	content = charclasscontent,
	$assert ']'};
constant {
	str = str};
failure {
	'$error' blank,
	str = $assert str};
identref {
	ident = identifier};
argref {
	'$arg' blank,
	index = $assert number};
subexpression :=
	'(' blank <
	$assert expression >
	blank $assert ')';
structure_element_named {
	name = identifier,
	blank '=' blank,
	rule = $assert expression};
structure_element_nameless {
	rule = $assert expression};
structure_element :=
	structure_element_named /
	structure_element_nameless;
structure_content :=
	$assert structure_element :
	*( blank ',' blank ~'}' <
		$assert structure_element) >
	?(blank ',');
structure {
	name = identifier,
	blank '{' blank,
	content = structure_content,
	blank $assert '}'};
any {
	'$any'};
eof {
	'$eof'};
dummy {
	'$dummy'};
marker {
	'$marker' blank,
	str = $assert str};
$pr assertable;
assertable < -10 = structure;
assertable <= identref;
assertable <= constant;
assertable <= argref;
assertable <= any;
assertable <= eof;
assert_modifier {
	'$assert' blank,
	rule = $assert assertable};
$pr elementary;
elementary < -10 = structure;
elementary <= identref;
elementary <= subexpression;
elementary <= constant;
elementary <= assert_modifier;
elementary <= argref;
elementary <= failure;
elementary <= charclass;
elementary <= any;
elementary <= eof;
elementary <= dummy;
elementary <= marker;
optional {
	'?' blank,
	rule = $assert elementary};
zeroormore {
	'*' blank,
	rule = $assert elementary};
oneormore {
	'%' blank,
	rule = $assert elementary};
funcarg_name {
	'$name' blank,
	name = $assert identifier};
funcarg_rule {
	rule = expression};
$pr funcarg;
funcarg < 10 = funcarg_rule;
funcarg <= funcarg_name;
funccall_arglist_content :=
	funcarg : *(blank ',' blank ~'}' < $assert funcarg) > ?(blank ',');
funccall_arglist :=
	'{' blank <
	?funccall_arglist_content >
	blank $assert '}';
funccall {
	'$call' blank,
	name = $assert identifier,
	blank,
	arglist = ?funccall_arglist};
$pr simple;
simple <= optional;
simple <= zeroormore;
simple <= oneormore;
simple <= funccall;
simple <= elementary;
andpred {
	'&' blank,
	rule = $assert simple};
notpred {
	'~' blank,
	rule = $assert simple};
$pr sequence_element;
sequence_element <= simple;
sequence_element <= andpred;
sequence_element <= notpred;
sequence_content :=
	sequence_element :
	*(blank <
		sequence_element);
sequence {
	content = sequence_content};
$pr flatseq_element;
flatseq_element <= sequence;
flatseq_content := flatseq_element : *(blank ':' blank < $assert flatseq_element);
flatseq {
	content = flatseq_content};
concat {
	'$concat' blank,
	rule = flatseq};
$pr frame_element;
frame_element <= concat;
frame_element <= flatseq;
frame_l := frame {
	left = frame_element,
	blank '<' blank,
	center = $assert frame_element};
frame_r := frame {
	center = frame_element,
	blank '>' blank,
	right = $assert frame_element};
frame_lr := frame {
	left = frame_element,
	blank '<' blank,
	center = $assert frame_element,
	blank '>' blank,
	right = $assert frame_element};
frame := frame_lr / frame_l / frame_r;
binary_content_full := binary_content {
	prefix = $assert expression,
	blank $assert ',' blank,
	infix = $assert expression,
	blank ',' blank ~'}',
	suffix = $assert expression,
	?(blank ',')};
binary_content_short := binary_content {
	prefix = $assert expression,
	blank $assert ',' blank,
	suffix = $assert expression,
	?(blank ',')};
binary_content := binary_content_full / binary_content_short;
binary {
	'$binary' blank,
	name = $assert identifier,
	blank $assert '{' blank,
	content = binary_content,
	blank $assert '}'};
$pr choice_element;
choice_element <= concat;
choice_element <= frame;
choice_element <= flatseq;
choice_element <= binary;
choice_content := choice_element : *(blank '/' blank < $assert choice_element);
choice {
	content = choice_content};
$pr expression;
expression <= choice;
assignment {
	target = identifier,
	blank ':=' blank,
	expr = $assert expression,
	blank $assert ';'};
structure_definition {
	name = identifier,
	blank '{' blank,
	content = structure_content,
	blank $assert '}',
	blank $assert ';'};
binary_definition {
	'$binary' blank,
	name = $assert identifier,
	blank $assert '{' blank,
	content = binary_content,
	blank $assert '}',
	blank $assert ';'};
prioritychoice_definition {
	'$pr' blank,
	name = $assert identifier,
	blank $assert ';'};
insertion {
	target = identifier,
	blank '<' blank,
	order = ?number,
	blank $assert '=' blank,
	expr = $assert expression,
	blank $assert ';'};
funcdef {
	'$function' blank,
	name = $assert identifier,
	blank $assert ';' blank,
	body = body,
	blank $assert '$end'
	blank $assert ';'};
returnstat {
	'$return' blank,
	expr = $assert expression,
	blank $assert ';'};
emptystatement {
	blank ';'};
$pr statement;
statement <= assignment;
statement <= structure_definition;
statement <= binary_definition;
statement <= prioritychoice_definition;
statement <= insertion;
statement <= funcdef;
statement < 10 = emptystatement;
$pr statement_last;
statement_last <= returnstat;
body_content :=
	*(statement > blank) :
	?statement_last;
body {
	content = body_content};
file {
	blank,
	body = body,
	blank $assert $eof};
$return file;
